# -*- coding: utf-8 -*-
"""load_chess_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wnw0uhjb97KPKCVxsH_ojcZBjY88z58l
"""

import torch
import chess.pgn
import torch.nn as nn
from google.colab import drive
import torch.nn.functional as F
import io
import numpy as np
drive.mount('/content/drive')

class BoardEval(nn.Module):
  def __init__(self, learning_rate):
    super(BoardEval, self).__init__()
    self.learning_rate = learning_rate

    self.a1 = nn.Conv2d(5 , 16, kernel_size=3, padding=1)
    self.a2 = nn.Conv2d(16, 16, kernel_size=3, padding=1)
    self.a3 = nn.Conv2d(16, 32, kernel_size=3,  stride=2)
    
    self.b1 = nn.Conv2d(32, 32, kernel_size=3, padding=1)
    self.b2 = nn.Conv2d(32, 32, kernel_size=3, padding=1)
    self.b3 = nn.Conv2d(32, 64, kernel_size=3,  stride=2)

    self.c1 = nn.Conv2d(64, 64 , kernel_size=2, padding=1)
    self.c2 = nn.Conv2d(64, 64 , kernel_size=2, padding=1)
    self.c3 = nn.Conv2d(64, 128, kernel_size=2,  stride=2)


    self.d1 = nn.Conv2d(128, 128, 1)
    self.d2 = nn.Conv2d(128, 128, 1)
    self.d3 = nn.Conv2d(128, 128, 1)

    #self.d1 = nn.Conv2d(256, 256, 1)


    self.bn1 = nn.BatchNorm2d(32)
    self.bn2 = nn.BatchNorm2d(64)
    self.bn3 = nn.BatchNorm2d(128)


    self.fc1 = nn.Linear(128, 64)
    self.fc2 = nn.Linear(64, 32)
    self.fc3 = nn.Linear(32, 1)

    self.tanh = nn.Tanh()

    self.loss = nn.MSELoss()


  def forward(self, x):
    x = x.view(-1, 5, 8, 8).float()

    x = F.relu(self.a1(x))
    x = F.relu(self.a2(x))
    x = F.relu(self.a3(x))
    x = self.bn1(x)

    x = F.relu(self.b1(x))
    x = F.relu(self.b2(x))
    x = F.relu(self.b3(x))
    x = self.bn2(x)

    x = F.relu(self.c1(x))
    x = F.relu(self.c2(x))
    x = F.relu(self.c3(x))
    x = self.bn3(x)

    x = F.relu(self.d1(x))
    x = F.relu(self.d2(x))
    x = F.relu(self.d3(x))


    x = x.view(-1, 128)

    x = self.fc1(x)
    x = self.fc2(x)
    x = self.fc3(x)

    x = self.tanh(x)

    return x


 

model1 = BoardEval(1e-5)
model1.load_state_dict(torch.load('/content/drive/MyDrive/chessmodel1.pt'))
model1.eval()

pgn = io.StringIO('''
      1. e4 e5 2. Nc3 Nf6 3. Bc4 Bc5 4. d3 d6 5. Bg5 Be6 6. Nd5 Bxd5 7. Bxd5 c6 
      8. Bb3 Nbd7 9. Nf3 O-O 10. O-O h6 11. Bh4 g5 12. Bg3 Qe7 13. Kh1 Kh8 14. 
      h4 Nh5 15. Qd2 Rg8 16. hxg5 Nxg3+ 17. fxg3 hxg5 18. c3 Rg7 19. d4 Bb6 20. 
      a4 a5 21. Kh2 Nf6 22. Rh1 Rh7+ 23. Kg1 Rxh1+ 24. Kxh1 Nxe4 25. Qe1 f5 26. 
      g4 Qh7+ 27. Kg1 exd4 28. Nxd4 c5 29. gxf5 cxd4 30. Qxe4 d3+ 0-1

    ''')

game = chess.pgn.read_game(pgn)
board = chess.Board()

print(game)

def board_to_tensor(board):
  torch_board = np.zeros((8, 8, 5))
  for x in range(8):
    for y in range(8):
      piece = board.piece_at(x + y*8)
      if piece == None:
        torch_board[y, x, 0] = 0
        torch_board[y, x, 1] = 0
      else:
        piece_type = {"P": 1, "N": 2, "B": 3, "R": 4, "Q": 5, "K": 6, \
                      "p": 9, "n":10, "b":11, "r":12, "q":13, "k": 14}[piece.symbol()]
        
        peice = f'{piece_type:04b}'

        # print(piece_type, ':', peice)

        color = piece.color
        torch_board[y, x, 0] = int(peice[0])
        torch_board[y, x, 1] = int(peice[1])
        torch_board[y, x, 2] = int(peice[2])
        torch_board[y, x, 3] = int(peice[3])


  # White to move represented with 1
  torch_board[:, :, 4] = {True:1, False:-1}[board.turn]
  return torch_board

def minimax(board, depth, White):

  if depth == 0:
    return model1(torch.tensor(board_to_tensor(board)))

  children = board.legal_moves

  if White == True:
    min = -1
    best_move = None
    for i in children:
      board.push(i)
      score = minimax(board, depth-1, False)
      if score > min:
        min = score
      board.pop()
    
    return score

  elif White == False:
    max = 1
    best_move = None
    for i in children:
      board.push(i)
      score = minimax(board, depth-1, True)
      if score < max:
        max = score
      board.pop()
                                                   
    return score

import matplotlib.pyplot as plt

def show_options(list_moves, list_scores):

  zipped = zip(list_moves, list_scores)

  print('-----------------------')

  sorted_zipped = sorted(zipped, key=lambda x:x[1])

  for i in range(len(sorted_zipped)):
    print(sorted_zipped[i])

  print('-----------------------')

board = chess.Board()

list_moves  = []
list_scores = []

while True:

  print(board)

  move = input()

  try:
    board.push_san(move)
  except:
    print('move not valid')
    continue

  max = 1
  best_move = None

  for i in board.legal_moves:
    board.push(i)
    list_moves.append(i)
    eval = minimax(board, 2, False)
    list_scores.append(eval)
    if  eval < max:
      max = eval
      best_move = i
    board.pop()

  show_options(list_moves, list_scores)
  
  board.push(best_move)

