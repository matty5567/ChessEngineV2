# -*- coding: utf-8 -*-
"""chess_eval_train.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14HZ4xfeN3y-qRxNghF46NfYDVQuCSFVO
"""

# !pip install pytorch_lightning
# !curl https://raw.githubusercontent.com/pytorch/xla/master/contrib/scripts/env-setup.py -o pytorch-xla-env-setup.py
# !python pytorch-xla-env-setup.py --version nightly --apt-packages libomp5 libopenblas-dev

#%%

import torch
import torch.nn as nn
import chess
import pytorch_lightning as pl
import chess.pgn
from torch.utils.data import DataLoader, Dataset
import torch.nn.functional as F
import torchvision
from pytorch_lightning.metrics.functional import accuracy
import numpy as np

#%%

class game_data(pl.LightningDataModule):
  def __init__(self, num_games, train_test_split):
    super(game_data, self).__init__()
    self.num_games = num_games
    self.train_test_split = train_test_split

    self.train_data_states = []
    self.test_data_states  = []
    self.train_data_labels = []
    self.test_data_labels  = []

    self.setup()

  
  def _board_to_tensor(self, board):
    '''
    Represents the board as (8, 8, 5) tensor. First 3 dims are 3 bit reprentation
    of pieces. 4th dimension represents the colour of the respective piece. 5th
    dimension is which player has next move
    '''

    torch_board = np.zeros((8, 8, 5))
    for x in range(8):
      for y in range(8):
        piece = board.piece_at(x + y*8)
        if piece == None:
          torch_board[y, x, 0] = 0
          torch_board[y, x, 1] = 0
        else:
          piece_type = {"P": 1, "N": 2, "B": 3, "R": 4, "Q": 5, "K": 6, \
                        "p": 9, "n":10, "b":11, "r":12, "q":13, "k": 14}[piece.symbol()]
          
          peice = f'{piece_type:04b}'

          # print(piece_type, ':', peice)

          color = piece.color
          torch_board[y, x, 0] = int(peice[0])
          torch_board[y, x, 1] = int(peice[1])
          torch_board[y, x, 2] = int(peice[2])
          torch_board[y, x, 3] = int(peice[3])


    # White to move represented with 1
    torch_board[:, :, 4] = {True:1, False:-1}[board.turn]

    return torch_board


  def setup(self):
    

    self.pgn = open('data.pgn')
    print('found pgn file')

    counter = 0
    num_states = 0
    num_white_wins = 0
    while True:

      if counter > self.num_games:
        break
      
      try:
        game = chess.pgn.read_game(self.pgn)

        match_result = game.headers['Result']

        if match_result == '*':
          continue

        result = {'1-0':1, '1/2-1/2':0,'0-1':-1}[match_result]

        if result == 1:
          num_white_wins += 1

        board = game.board()
        for move in game.mainline_moves():
          board.push(move)
          board_tensor = self._board_to_tensor(board)

          if counter < self.num_games * self.train_test_split:
            self.train_data_states.append(board_tensor)
            self.train_data_labels.append(result)

          else:
            self.test_data_states.append(board_tensor)
            self.test_data_labels.append(result)
          
          num_states += 1
      
        counter += 1
        if counter % 1000 == 0:
          print(f'{counter} / {self.num_games}, total number of states: {num_states}')
      except Exception as e:
        print(e)
        break


data = game_data(30000, 0.8)

#%%

np.savez('train_data.npz', np.array(data.train_data_states), np.array(data.train_data_labels))
print('next')
np.savez('test_data.npz', np.array(data.test_data_states), np.array(data.test_data_labels))



#%%

class Data(Dataset):
  def __init__(self):
  
      self.test_states  = np.load('test_data.npz')['arr_0']
      self.test_labels  = np.load('test_data.npz')['arr_1']

      self.train_states  = np.load('train_data.npz')['arr_0']
      self.train_labels  = np.load('train_data.npz')['arr_1']




test_data = Data()


#%%

class BoardEval(pl.LightningModule):
  def __init__(self):
    super(BoardEval, self).__init__()

    self.a1 = nn.Conv2d(5 , 16, kernel_size=3, padding=1)
    self.a2 = nn.Conv2d(16, 16, kernel_size=3, padding=1)
    self.a3 = nn.Conv2d(16, 32, kernel_size=3, stride=2)

    self.b1 = nn.Conv2d(32, 32, kernel_size=3, padding=1)
    self.b2 = nn.Conv2d(32, 32, kernel_size=3, padding=1)
    self.b3 = nn.Conv2d(32, 64, kernel_size=3, stride=2)

    self.c1 = nn.Conv2d(64, 64 , kernel_size=2, padding=1)
    self.c2 = nn.Conv2d(64, 64 , kernel_size=2, padding=1)
    self.c3 = nn.Conv2d(64, 128, kernel_size=2, stride=2)

    self.d1 = nn.Conv2d(128, 128, 1)
    self.d2 = nn.Conv2d(128, 128, 1)
    self.d3 = nn.Conv2d(128, 128, 1)

    self.fc1 = nn.Linear(128, 1)

    self.loss = nn.MSELoss()
    self.tanh = nn.Tanh()

  def forward(self, x):
    x = x.view(-1, 5, 8, 8)

    x = F.relu(self.a1(x))
    x = F.relu(self.a2(x))
    x = F.relu(self.a3(x))

    x = F.relu(self.b1(x))
    x = F.relu(self.b2(x))
    x = F.relu(self.b3(x))

    x = F.relu(self.c1(x))
    x = F.relu(self.c2(x))
    x = F.relu(self.c3(x))

    x = F.relu(self.d1(x))
    x = F.relu(self.d2(x))
    x = F.relu(self.d3(x))

    x = x.view(-1, 128)
    x = self.fc1(x)
    x = self.tanh(x)

    return x


  def training_step(self, batch, batch_id):
    states, results = batch

    output = self(states)
    results = results.to(torch.float32).unsqueeze(1)
    loss = self.loss(output, results)
    self.log('train loss', loss)
    #self.log('train accuracy', accuracy(output, results))
    return loss

  
  def validation_step(self, batch, batch_id):
    states, results = batch
    output = self(states)
    results = results.unsqueeze(1)
    loss = self.loss(output, results)
    self.log('test loss', loss)
    #self.log('train accuracy', accuracy(output, results))
    return loss


  def configure_optimizers(self):
    optimizer = torch.optim.Adam(self.parameters())
    return optimizer

model = BoardEval()

trainer = pl.Trainer(gpus=-1, progress_bar_refresh_rate=15, max_epochs=10)
trainer.fit(model, data)

# Commented out IPython magic to ensure Python compatibility.

# %reload_ext tensorboard
# %tensorboard --logdir lightning_logs/

